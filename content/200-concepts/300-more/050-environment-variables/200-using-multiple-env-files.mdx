---
title: 'Using multiple .env files'
metaTitle: 'Using multiple .env files.'
metaDescription: 'Learn how to setup a dedicated testing environment using multiple .env files.'
tocDepth: 2
---

<TopBlock>

When developing an application you will generally have different environments such as `development`, `test` and `production` which you use to **separate the stages of the development cycle**.

Prisma can access each environment via a [connection url](../../../reference/database-reference/connection-urls) which is stored in a `.env` file.

</TopBlock>

## Scenario: Running integration tests

You have three [connection urls](../../../reference/database-reference/connection-urls) for each of your environments stored in a single `.env` file:

```env file=.env

// Connection URL to development environment
DEVELOPMENT_DATABASE_URL="postgresql://prisma:prisma@localhost:5433/development"

// Connection URL to testing environment
TESTING_DATABASE_URL="postgresql://prisma:prisma@localhost:5433/test"

// Connection URL to production environment
PRODUCTION_DATABASE_URL="postgresql://prisma:prisma@localhost:5433/production"

```

<Admonition type="warning">

`PRODUCTION_DATABASE_URL` is added above for clarity in explaining the scenario. It's **not recommended** to store your production credentials locally, even if they are git ignored.

</Admonition>

You are running your integration test inside a [docker container](../../../guides/testing/integration-testing#add-docker-to-your-project) which, upon startup:

1. Creates a database
1. Runs a migration with your application schema
1. Seeds the database with fake data
1. Runs the tests
1. **Deletes all the data in the database**

The docker container is passed an environment variable from the `.env` file which specifies which database it should use. 

There is a risk that you accidentally pass the **wrong** environment variable to the docker container and **all the data is deleted** once the tests are finished running.

One solution is to have multiple `.env` files which each represent a different environment. In practice this means you create a file for each of your environments:

- `.env.development`
- `.env.test`

<Admonition type="warning">

`.env.production` is omitted from the above list as it's **not recommended** to store your production credentials locally, even if they are git ignored.

</Admonition>

Then using a package like [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli), you can load the correct connection URL for the environment you are working in.


## How to setup multiple `.env` files with dotenv-cli

For the purpose of this guide it is assumed you have a dedicated development database which you use whilst developing your application. 

1. Rename your `.env` file to `.env.development`

```env file=.env.development
DATABASE_URL="postgresql://prisma:prisma@localhost:5433/development"
```

2. Create a new `.env.test` file and change the database name to test (or your preferred name)

```env file=.env.test
DATABASE_URL="postgresql://prisma:prisma@localhost:5433/test"
```

3. Install [`dotenv-cli`](https://www.npmjs.com/package/dotenv-cli)

In order for Prisma and Jest to know which `.env` file to use, alter your package.json scripts to include and call the `dotenv` package and specify which file to use depending on what commands you are running and in which environment you want them to run.

<Admonition type="info">

Any top level script that is running the tests and migrations needs the dotenv command before it. This makes sure that the env variables from `.env.test` are passed to all commands including Jest.

</Admonition>

### Migration script

```json file=package.json
  "scripts": {
    "migrate:mysql": "dotenv -e .env.test -- npx prisma migrate dev --name mysql-init",
  },
```

### Test script

```json file=package.json
  "scripts": {
    "test": "dotenv -e .env.test jest -i"
  },
```
